# OpenCLC
This repo holds an experimental compiler for opencl c source code that automatically creates kernel invocation symbols to avoid contact with the underlying OpenCL driver. This provides an experience to using `nvcc` without language extensions or commiting to the proprietary cuda runtime.

Additionally, `openclc` can be used to simply create SPIR-V binary from opencl source code for use outside of the openclc runtime.

# Installation

`install.sh` will download the lastest release for your os/arch and extract the contents to `$HOME/.openclc`.
```sh
curl -fsSL https://raw.githubusercontent.com/e253/openclc/main/install.sh | bash
```

Alternatively, download the release archive and extract it anywhere you'd like.

OpenCLC does not need to be installed in any specific location.

# Usage

`vec_add.cl`
```c
kernel void add(constant float *A, constant float *B, global float *C)
{
    size_t gid = get_global_id(0);
    C[gid] = A[gid] + B[gid];
}
```
`vec_add.c`
```c
#include "kernels.h" // generated by openclc
#include <assert.h>
#include <stdio.h>

int main()
{
    oclcInit();

    int n = 256;
    size_t sz = n * sizeof(float);

    // Allocate Host Memory
    float* A = (float*)malloc(sz);
    float* B = (float*)malloc(sz);
    float* C = (float*)malloc(sz);

    // Initialize Host Memory
    for (int i = 0; i < n; i++) {
        A[i] = i;
        B[i] = i;
        C[i] = 0;
    }

    // Allocate Device Memory
    float* dA = (float*)oclcMalloc(sz);
    float* dB = (float*)oclcMalloc(sz);
    float* dC = (float*)oclcMalloc(sz);

    // Copy Host Values to the Device Memory
    oclcMemcpy(dA, A, sz, oclcMemcpyHostToDevice);
    oclcMemcpy(dB, B, sz, oclcMemcpyHostToDevice);
    oclcMemcpy(dC, C, sz, oclcMemcpyHostToDevice);

    dim3 gridDim = { n / 32 };
    dim3 blockDim = { 32 };

    // Invoke the Kernel!
    add(gridDim, blockDim, dA, dB, dC);

    oclcMemcpy(C, dC, sz, oclcMemcpyDeviceToHost);

    oclcDeviceSynchronize();

    for (int i = 0; i < n; i++) {
        assert(C[i] == 2 * i);
    }

    puts("\n---------------------------\n");
    puts("Passed");
    puts("\n---------------------------\n");

    oclcFree(dA);
    oclcFree(dB);
    oclcFree(dC);
}
```

Create `kernels.h` and `kernels.c` with `openclc` and then use your host compiler `$CC` to build the executable.
```sh
openclc vec_add.cl
$CC vec_add.c kernels.c ./runtime/opencl_rt.c -I./runtime -o vadd
```

# Dependencies
- [zig-bootstrap](https://github.com/ziglang/zig-bootstrap/tree/ec2dca85a340f134d2fcfdc9007e91f9abed6996) : Rev `ec2dca85a340f134d2fcfdc9007e91f9abed6996`
- [SPIRV-LLVM-Translator](https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases/tag/v18.1.2) : Release `v18.1.2`
- [SPIRV-Headers](https://github.com/KhronosGroup/SPIRV-Headers/tree/4f7b471f1a66b6d06462cd4ba57628cc0cd087d7) : Rev `4f7b471f1a66b6d06462cd4ba57628cc0cd087d7`
- [SPIRV-Tools](https://github.com/KhronosGroup/SPIRV-Tools/releases/tag/v2024.2) : Release `v2024.2`
- [fmt](https://github.com/fmtlib/fmt)
- LLVM-18 (Build Dependency) Use `llvm.sh` to install it with `apt`. Any 18.x *should* work.

# Build

`Openclc` only builds on Debian, but can cross compile to many targets with the help of `zig`.

1. Get LLVM 18
2. Get ZVM, then zig 0.13.0
3. `./build-deps.sh <zig-target-triple> <mcpu>`
4. `./build-openclc.sh <zig-target-triple> <mcpu>`
5. `./<zig-target-triple>-<mcpu>/bin/openclc`

# Credits
1. Khronos Group, for the `SPIRV-Tools`, `SPIRV-LLVM-Translator` dependencies
2. Google for the `CLSPV` project, that works very similarly to this project, but instead targets a vulkan runtime. I couldn't have figured out the clang frontend calls otherwise.
